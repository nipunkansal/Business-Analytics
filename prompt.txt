from langchain.agents import Tool, AgentExecutor, BaseSingleActionAgent
from langchain import OpenAI, SerpAPIWrapper
from langchain.chains import LLMChain
from langchain.prompts import BaseChatPromptTemplate
from langchain.schema import AgentAction, AgentFinish, HumanMessage
from typing import List, Tuple, Any, Union
from langchain.tools import tool

# Define a custom tool
@tool
def custom_tool(query: str) -> str:
    """A custom tool that performs a specific task."""
    # Implement your custom logic here
    return f"Result for {query}"

# Use a pre-built tool (e.g., SerpAPI for search)
search = SerpAPIWrapper()

tools = [
    Tool(
        name="Search",
        func=search.run,
        description="useful for when you need to answer questions about current events"
    ),
    Tool(
        name="Custom Tool",
        func=custom_tool,
        description="useful for performing custom tasks"
    )
]

class CustomPromptTemplate(BaseChatPromptTemplate):
    template: str
    input_variables: List[str] = ["input", "tools", "tool_names", "agent_scratchpad"]

    def format_messages(self, **kwargs) -> str:
        intermediate_steps = kwargs.pop("intermediate_steps")
        thoughts = ""
        for action, observation in intermediate_steps:
            thoughts += action.log
            thoughts += f"\nObservation: {observation}\nThought: "
        kwargs["agent_scratchpad"] = thoughts
        return [HumanMessage(content=self.template.format(**kwargs))]

prompt = CustomPromptTemplate(
    template="Answer the following questions as best you can. You have access to the following tools:\n\n{tools}\n\nUse the following format:\n\nQuestion: the input question you must answer\nThought: you should always think about what to do\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n... (this Thought/Action/Action Input/Observation can repeat N times)\nThought: I now know the final answer\nFinal Answer: the final answer to the original input question\n\nQuestion: {input}\nThought:{agent_scratchpad}",
    tools=tools,
    tool_names=", ".join([tool.name for tool in tools])
)

class CustomAgent(BaseSingleActionAgent):
    def __init__(self, tools, llm_chain):
        self.tools = tools
        self.llm_chain = llm_chain

    @property
    def input_keys(self):
        return ["input"]

    def plan(self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any) -> Union[AgentAction, AgentFinish]:
        thought = self.llm_chain.run(**kwargs)
        action = AgentAction(tool="Search", tool_input=kwargs["input"], log=thought)
        return action

    async def aplan(self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any) -> Union[AgentAction, AgentFinish]:
        raise NotImplementedError("Async not implemented")

agent = CustomAgent()

agent_executor = AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=True)

response = agent_executor.run("What is the current price of Bitcoin?")
print(response)
